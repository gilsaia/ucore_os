# 练习一
按照文档所说，除了几个特殊量其他全置零即可
## 问题一
context保存的是常规的寄存器 用来在进程切换时候保存上下文，也就是保存当前运行的状态，之所以段寄存器以及cr等等不需要存因为在内核中相当于一个大的进程这些都是共用的，实际利用的地方是在switch.S中的switch_to函数

中断帧的指针，实际在lab1中就有用到
* 当创建一个新进程时，我们先分配一个进程控制块proc，并设置好其中的tf及context变量；
* 然后，当调度器schedule调度到该进程时，首先进行上下文切换，这里关键的两个上下文信息是context.eip和context.esp，前者提供新进程的起始入口，后者保存新进程的trap_frame地址。
* 上下文切换完毕后，CPU会跳转到新进程的起始入口。在新进程的起始入口中，根据trap_frame信息设置通用寄存器和段寄存器的值，并执行真正的处理函数。可见，tf与context共同用于进程的状态保存与恢复。
# 练习二
按要求初始化即可。。。前三项按照文档说明记得判断是否成功不成要释放空间
## 问题一
最大pid号是线程的两倍，所以理论上所有线程同时存在也是能够分配不同的pid的，函数内部做了遍历来寻找一个与当前存在的pid都不一样的pid，能够保证都不相同
# 练习三
看要跑的是不是当前线程。。。不是的话先禁用中断防止中间切换过程中出现中断打乱堆栈结构。。然后换进程换栈换页目录表换上下文。。再启用中断。。换完了。。
## 问题一
很明显俩进程。。写的清清楚楚。。。还需要特意说吗。。
## 问题二
intr_save读进来当前标志寄存器如果允许中断的话flag标上禁用。。intr_restore恢复。。