同理，合并时候要修改一些玩意 proc.c又多初始化一堆... trap.c加个调用函数..
# 练习一
## 问题一

先说RR实现的
|函数|作用|
|-|-|
|init|初始化链表|
|enqueue|添加进链表重设时间片设置进程块指向链表|
|dequeue|从链表删除|
|pick_next|找到链表指向的下一个|
|proc_tick|时间计数|

再说封装的
|函数|作用|
|-|-|
|init|初始化链表，设置最大时间片长度|
|enqueue|
|dequeue|
|pick_next|以上直接调用|
|proc_tick|调度内核进程直接调度，其他调用RR对应函数|
|wakeup_proc|各种检查后放入调度链表|
|schedule|当前进程进链表，选一个出链表，跑跑跑起来！|

## 问题二

基础的思路很简单 从单优先级变成多优先级

原来维护的链表变成链表组

enqueue时候看剩余时间是否为0,为0说明时间片不够其使用，优先级降低时间片增长，否则说明足够是其他原因优先级不需要变化

调度时从最高优先级只有当前优先级不存在则寻找下一优先级

可能出现饥饿现象

# 练习二

实现的部分看代码吧...就是一个堆...

文档中见提出的两个问题

最大stride和最小stride差值一定小于最大步长 反证法 推出低优先级被选中 矛盾

无符号减法实际上是转成有符号来减，所以一半就可以理解了