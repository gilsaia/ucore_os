# 练习0

拷代码...没啥说的 挑战部分没拷过来因为似乎是lab1特有的(

# 练习1

文档看的是真的头晕...不应该分好几天看的...

给的代码写的很全了基本已经...前两个默认函数完全看不出哪里需要改的样子=_=分配内存的加个置位找个位置就完了
回收内存的寻找位置要注意..然后就是该退出循环的地方赶紧退啊=_=当然这玩意只是常数级别的优化...没啥大用...但是确实看不出来还有哪能优化了...

然后发现一个自己写的bug...我默认用的添加链表的方法是add_after，而最开始的一个按照默认顺序是没有检查的...换一下顺序就好了..
# 练习2

[]操作符比取地址运算符优先级要高...这玩意卡了我半天没想明白...还有页表中存的都是物理地址，需要做一次转换才能拿来用

还有一个需要自己查的知识点...c里面的取址以及指针这些都是偏移地址或者虚拟地址...所以操作时候务必要注意参数是物理地址还是虚拟地址

pte和pde的高20位存的对应表项的物理地址，因为是按页对齐的所以低十二位可以不用，在这里实际用作属性位，具体含义在mmu.h里有写

至于页访问异常的问题...这不是lab3的page fault处理吗...我就直接粘后面的说明了...
>CPU会把产生异常的线性地址存储在CR2中，并且把表示页访问异常类型的值（简称页访问异常错误码，errorCode）保存在中断栈中。页访问异常也是一种异常，所以针对一般异常的硬件处理操作是必须要做的，即CPU在当前内核栈保存当前被打断的程序现场，即依次压入当前被打断程序使用的EFLAGS，CS，EIP，errorCode；由于页访问异常的中断号是0xE，CPU把异常中断号0xE对应的中断服务例程的地址（vectors.S中的标号vector14处）加载到CS和EIP寄存器中，开始执行中断服务例程。这时ucore开始处理异常中断，首先需要保存硬件没有保存的寄存器。在vectors.S中的标号vector14处先把中断号压入内核栈，然后再在trapentry.S中的标号__alltraps处把DS、ES和其他通用寄存器都压栈。自此，被打断的程序执行现场（context）被保存在内核栈中。接下来，在trap.c的trap函数开始了中断服务例程的处理流程。

说明中并未说明两个操作的顺序，按照errcode在trapframe中的顺序，我暂且理解成在压入cs和eip后进行的压入cr2保存ercode操作。

# 练习3

基本按照注释来即可，有问题的是注释中说的需要检测当前页表项是否在被处理器使用再考虑是否清空，但实际上这个判断的逻辑...在函数内部实现的...

页表和page的关系嘛( •̅_•̅ ) 我理解的页表存储的是映射关系嘛 可能会有多个页表项对应同一个实际的物理页的关系 而page是管理实际的物理内存的 我们可以用各种内存管理的算法来调整 页表项里的某些属性可能和实际的page中某些属性有所关联？（现在能明显看出来的权限方面 系统内核占用的页在两个部分都有属性分别设置这样？

希望虚拟地址和实际地址相同_(:3」∠)_，在这里就是差一个便宜量嘛 我们把偏移量改成0就完了( • ̀ω•́ )✧