# 练习一
完成缺页异常处理的一部分 这里是处理未分配物理页的部分 
调用了我们之前写的函数获取页表项，参考之前写的函数几种可能的返回值，返回一个NULL表示一种是未建立对应页表同时不允许建新页一种是实际的物理内存已经占满没有地方分配，第一种在这里的调用显然不可能，第二种的话我认为应该调用swap_out_victim函数相关的来利用页面置换算法换出页面腾出内存，但是这里实际还没有形成真正的页面置换，因为还没有进程线程的概念，再仔细观察函数，ret已经设为无内存错误，参考原函数写法我们也做同样的错误处理即可。
## 问题一
emmmmmmm 看看mmu.h里面对于页表项后12位用法的定义 里面有意思的几个
|表项|所在位|含义|
|-|-|-|
|PTE_PWT|0x008|写直达|
|PTE_PCD|0x010|禁止Cache|
|PTE_A|0x020|cpu是否访问过|
|PTE_D|0x040|是否需要写回|
很明显最后两个与我们的页面置换算法是可能产生关联的，我写上前两项是因为第一次意识到这个问题，以前对于写直达之类的问题从来没有深究过到底是在哪里起作用的，在页表项填充就可以对cpu产生效果，这里深想下去还会有一个结果我在练习二来说明
## 问题二
唔。。。这不是真的问过一遍吗。。。首先触发异常了那一串东西肯定要压栈了。。。errorcode表示异常的原因。。然后找中断向量走中断处理函数巴拉巴拉。。
# 练习二
缺页处理的另一部分以及页面置换机制的某两个实现
这里缺页处理的情况是内存被swap出去的情况，即将对应页面从磁盘中换入，这里代码按照注释倒是不难理解也不难写，但是让我比较疑惑的一个问题是，在什么地方将页面换出去的呢？首先查看代码我们知道实际调用了写和读函数的调用是swap.c的swap_in和swap_out，那么这里调了swap_in，out在哪里呢？接着写页面置换机制，这里写的实际主要是对mm的列表进行操作。。实际的读入读出不是发生在这里 （顺便这俩函数都有一个毫无意义的参数。。。应该是其他的机制也许会用到这样？）写完之后我们调用debug函数观察了一下当调用我们写的机制时候产生的函数调用关系。发现实际是alloc_page写好了消极的换出页面处理（练习一的疑问解决），当然会产生换出的前提是。。。它在check_swap里面偷偷把空闲页面给赋0了。。。假装没有页面。。。
还有另一个问题，我在写lab2时候就在考虑，我们写的函数究竟是在哪里用到的？因为页表的查询给我们的感觉实际是由cpu硬件来自动执行的，但是很显然我们写的函数是不可能放到硬件去走的，cpu实际上有的是页目录表的地址以及设置的对于分页机制的开启与否，那么实际上正常的访问查询页表就是由cpu自动完成的，当出现缺页异常的时候我们在trap.c的中断处理函数写好了调用我们自己写的dopgfault函数，这里面我们需要用到之前写的东西。。也就是页表的分配是要靠我们自己来的，所以初始时候要赋成全0,这就是cpu默认认为页表项是符合它定义的要求的，全0就是提醒它页表还未分配（就情况来看可能最后一位PTE_P置0已经足够达成效果）
## 问题
唔。。应该是够的 设计方案见下面的扩展练习 换出的页的特征很明显就是按照讲解的 未读取 写入未读取 读取未写入 写入且读取来找就好了判断的话很明显上面讲的页表项就有这个功能了 现在没有进程线程的概念只能作为消极的处理方法 实际上我认为更理想的就是单开一个进程或者线程来跑页面置换算法